引用是除指针外另一个可以产生多态效果的手段。这意味着，一个基类的引用可以指向它的派生类实例。例如：
class A;
class B: public A
{
   ...
};
B b;
A & aRef = b;    // 基类引用指向派生类
如果A类中定义有虚函数，并且在B类中重写了这个虚函数，就可以通过aRef产生多态效果。


[引用初始化]
关于引用的初始化有两点值得注意：
（1）当初始化值是一个左值（可以取得地址）时，没有任何问题；
（2）当初始化值不是一个左值时，则只能对一个const T&（常量引用）赋值。而且这个赋值是有一个过程的：
首先将值隐式转换到类型T，然后将这个转换结果存放在一个临时对象里，最后用这个临时对象来初始化这个引用变量。
例子：
double& dr = 1; // 错误：需要左值
const double& cdr = 1; // ok
第二句实际的过程如下：
double temp = double(1);
const double& cdr = temp;
特别注意第二种情况 会产生临时对象，此时引用绑定的是哪个临时对象 如果是非const说明你想对引用的对象进行修改，
此时你修改的是绑定的临时对象，原对象没变，也就没有达到你的目的，所以c++明确禁止这样初始化。使用时候尽量避免这种初始化，
会导致产生临时变量的开销，大的对象时这个开销是很大的。
补充：何时产生临时对象。一 需要隐式类型转换时；二 函数返回值。 上述临时对象就是第一种情况。


[右值引用]
主要用于常量的引用
右值引用是C++11新增加的特性，用于引用右值变量
由于单引用只能引用左值变量，当引用为右值时使用&&，引用右值变量
编译需要增加--std=c++11


[引用网址]

